# A 'sparse array' wrapper

# distutils: language = c++

### TODO:
#  1. expose dimensionality template param
#  2. need to expose iterators to sp_map_t?
#  4. check arg not None
#  5. translate all C++ exceptions
#  6. int types between C++ and Cy, esp int, npy_intp etc
#  7. slices
#
#  TYPES:
#  8. specify casting rules
#  9. less copying in casting in binops (MapArray + MapArray)
#  10. binops: func ptrs in inner loops are likely not good for inlining?
#  11. add more tests for mixed binops
#  12. add tests with NAN and INF, where supported
#
#  7. construct from_dense
#  8. add more binops (__mul__) & make them cast a la __add__
#  9. add matmul and operator @
#  10. add more Py types
#  12. to_csr interop
#  13. add bitwise ops so that (1 < x) & (x < 2) works a la numpy
#
#  Minor quibbles:
#  1. access to elements of fixed_capacity: operator[] or ELEM macro
#  2. how to keep typedefs in sync between Cy and C++
#  3. avoid having a CMD string substitution
#  4. special-case dtypes on the C++ template level (npy_bool, npy_complex?)

import numpy as np
cimport numpy as cnp
from numpy cimport PyArray_SimpleNew, PyArray_DATA, PyArray_SIZE, npy_intp, npy_bool


cdef extern from "fixed_cap.h" namespace "sparray":
    cdef cppclass fixed_capacity[I]:
        fixed_capacity() except +
        fixed_capacity(const I*) except +
        I& operator[](size_t j) except +
        long int[] elem_


ctypedef long int single_index_type            # this needs ot be in sync w/C++
ctypedef fixed_capacity[long int] index_type   # XXX: can't do fixed_capacity[single_index_type]


cdef extern from "sp_map.h" namespace "sparray":
    cdef cppclass map_array_t[T]:
        map_array_t() except +
        map_array_t(const map_array_t&) except +
        void copy_from[S](const map_array_t[S]*) except +

        size_t ndim() const
        index_type shape() const
        index_type get_min_shape() const
        void set_shape(const index_type&) except +

        T fill_value() const
        void set_fill_value(T value)

        size_t count_nonzero() const

        # single element accessors
        T get_one(const index_type& idx) const 
        void set_one(const index_type& idx, const T& value)

        void todense(void* dest, const single_index_type num_elem) except +

        void inplace_unary_op(T (*fptr)(T x, T a, T b), T a, T b)  # x <- f(x, a, b)
        void inplace_binary_op(T (*fptr)(T x, T y, T a, T b),
                               const map_array_t[T] *p_other, T a, T b) except +  # x <- f(x, y, a, b)

        void apply_binop[S](T (*binop)(S x, S y),
                         const map_array_t[S] *first,
                         const map_array_t[S] *second) except +;  # z[i] <- f(x[i], y[i]) for z in self, 
                                                                  #   x in first, y in second

cdef extern from "elementwise_ops.h" namespace "sparray":
    T linear_unary_op[T](T, T, T)
    T power_unary_op[T](T, T, T)
    T linear_binary_op[T](T, T, T, T)
    T mul_binary_op[T](T, T, T, T)

    npy_bool equal[S](S, S)
    npy_bool less_equal[S](S, S)
    npy_bool greater_equal[S](S, S)
    npy_bool not_equal[S](S, S)
    npy_bool less[S](S, S)
    npy_bool greater[S](S, S)


cdef index_type index_from_tuple(tuple tpl):
    # conversion helper: 2D only.
    cdef index_type idx
    idx[0] = tpl[0]
    idx[1] = tpl[1]
    return idx


cdef object convert_io(object value, int typenum):
    # XXX: this should probably be moved to C++ level
    if typenum == cnp.NPY_BOOL:
        return (value != 0)
    return value


{{py: 
CTYPES = ['npy_bool', 'long', 'float', 'double']
TNUMS = ['cnp.NPY_BOOL', 'cnp.NPY_LONG', 'cnp.NPY_FLOAT', 'cnp.NPY_DOUBLE']
CONDS = ['if'] + ['elif']*(len(TNUMS) - 1)
}}


cdef union union_t:
{{for CT in CTYPES}}
    map_array_t[{{CT}}] *{{CT}}_ptr
{{endfor}}


cdef class MapArray:
    cdef union_t p
    cdef int typenum

    __array_priority__ = 10.1     # equal to that of sparse matrices

    def __init__(self, shape=None, fill_value=0, dtype=float):
        pass

    def __cinit__(self, shape=None, fill_value=0, dtype=float, *args, **kwds):

        # this seems to convert float etc to numpy dtypes
        dtype = np.dtype(dtype)
        self.typenum = dtype.num

        # allocate memory on the correct type pointer
        {{for NUM, CT, IF in zip(TNUMS, CTYPES, CONDS)}}
        {{IF}} self.typenum == {{NUM}}:
            self.p.{{CT}}_ptr = new map_array_t[{{CT}}]()
        {{endfor}}
        else:
            raise TypeError("dtype %s  not supported." % dtype)

        # handle shape
        try:
            self._set_shape(shape)
        except TypeError:
            raise TypeError("Shape must be a tuple, got %s." % shape)

        #handle fill_value
        self.fill_value = fill_value

    def __dealloc__(self):
        {{for NUM, CT, IF in zip(TNUMS, CTYPES, CONDS)}}
        {{IF}} self.typenum == {{NUM}}:
            del self.p.{{CT}}_ptr
        {{endfor}}
        # NB: this if-then-else is deliberately not closed off with an error.
        # The reason is that if a dtype lookup fails in __cinit__, it raises
        # a TypeError, and then __dealloc__ is called by Cython anyway.
        # The result is a spurious message from __dealloc__ saying that
        # the error was ignored.

    #### Public interface accessors #####

    property dtype:
        def __get__(self):
            # per https://mail.scipy.org/pipermail/numpy-discussion/2013-October/068002.html
            return np.dtype(cnp.PyArray_TypeObjectFromType(self.typenum))

    property ndim:
        def __get__(self):
            {{for NUM, C, IF in zip(TNUMS, CTYPES, CONDS)}}
            {{IF}} self.typenum == {{NUM}}:
                return self.p.{{C}}_ptr.ndim()
            {{endfor}}
            else:
                raise TypeError("ndim: dtype = %s unhandled." % self.dtype)

    property fill_value:
        def __get__(self):
            {{for NUM, C, IF in zip(TNUMS, CTYPES, CONDS)}}
            {{IF}} self.typenum == {{NUM}}:
                return convert_io(self.p.{{C}}_ptr.fill_value(), self.typenum)
            {{endfor}}
            else:
                raise TypeError("fill_value: dtype = %s unhandled." % self.dtype)

        def __set__(self, value):
            {{for NUM, C, IF in zip(TNUMS, CTYPES, CONDS)}}
            {{IF}} self.typenum == {{NUM}}:
                self.p.{{C}}_ptr.set_fill_value(convert_io(value, self.typenum))
            {{endfor}}
            else:
                raise TypeError("fill_value: dtype = %s unhandled." % self.dtype)

    property shape:
        def __get__(self):
            cdef index_type sh
            {{for NUM, C, IF in zip(TNUMS, CTYPES, CONDS)}}
            {{IF}} self.typenum == {{NUM}}:
                sh = self.p.{{C}}_ptr.shape()
                return sh[0], sh[1]           # TODO: ndim != 2
            {{endfor}}
            else:
                raise TypeError("shape: dtype = %s unhandled." % self.dtype)

    cdef void _set_shape(self, object shape):
        # shape setter is private, only call it from __cinit__
        if not shape:
            shape = (0,)*self.ndim

        if len(shape) != self.ndim:
            raise TypeError("Shape %s not undestood." % str(shape))

        cdef index_type shp = index_from_tuple(shape)
        {{for NUM, C, IF in zip(TNUMS, CTYPES, CONDS)}}
        {{IF}} self.typenum == {{NUM}}:
            self.p.{{C}}_ptr.set_shape(shp)
        {{endfor}}
        else:
            raise TypeError("shape setter: dtype = %s unhandled." % self.dtype)

    def count_nonzero(self):
        {{for NUM, C, IF in zip(TNUMS, CTYPES, CONDS)}}
        {{IF}} self.typenum == {{NUM}}:
            return self.p.{{C}}_ptr.count_nonzero()
        {{endfor}}
        raise TypeError("count_nonzero: dtype = %s unhandled." % self.dtype)


    def copy(self, dtype=None):
        if dtype is None:
            dtype = self.dtype
        newobj = MapArray(dtype=dtype)

        cdef int typenum_src = self.typenum
        cdef int typenum_dest = newobj.typenum
        {{for NUM, CT, IF in zip(TNUMS, CTYPES, CONDS)}}
        {{IF}} typenum_src == {{NUM}}:
            # found self.dtype, on to the dest dtype now
            {{for NUM1, CT1, IF1 in zip(TNUMS, CTYPES, CONDS)}}
            {{IF1}} typenum_dest == {{NUM1}}:
                newobj.p.{{CT1}}_ptr.copy_from[{{CT}}](self.p.{{CT}}_ptr)
                return newobj
            {{endfor}}
        {{endfor}}
        raise TypeError("copy: never be here. dtype = " % self.dtype)

    def astype(self, dtype):
        # Syntactic sugar: .copy() preserves dtype, .astype changes it.
        return self.copy(dtype)

    def todense(self):
        cdef int nd
        cdef cnp.ndarray a

        {{for NUM, CT in zip(TNUMS, CTYPES)}}
        if self.typenum == {{NUM}}:
            nd = <int>self.p.{{CT}}_ptr.ndim()
            a = PyArray_SimpleNew(nd,
                                  <npy_intp*>self.p.{{CT}}_ptr.shape().elem_,
                                  {{NUM}})
            self.p.{{CT}}_ptr.todense(PyArray_DATA(a), PyArray_SIZE(a))
            return a
        {{endfor}}
        raise TypeError("todense: never be here. dtype = " % self.dtype)        


    ##### Single element access #####

    def __getitem__(self, tpl):
        # 2D is hardcoded; no slicing; no input validation
        cdef index_type idx = index_from_tuple(tpl)

        {{for NUM, CT in zip(TNUMS, CTYPES)}}
        if self.typenum == {{NUM}}:
            return convert_io(self.p.{{CT}}_ptr.get_one(idx), self.typenum)
        {{endfor}}
        raise TypeError("__getitem__: dtype = %s not understood." % self.dtype)

    def __setitem__(self, tpl, value):
        cdef index_type idx = index_from_tuple(tpl)

        {{for NUM, CT, IF in zip(TNUMS, CTYPES, CONDS)}}
        {{IF}} self.typenum == {{NUM}}:
            self.p.{{CT}}_ptr.set_one(idx, convert_io(value, self.typenum))
        {{endfor}}
        else:
            raise TypeError("__setitem__: dtype = %s not understood." % self.dtype)

    ###### Arithmetics #######

    # TODO: 
    #        3. add more arithm ops: sub, mul, div, l/r shifts, mod etc

    def __iadd__(MapArray self not None, other):

        if isinstance(other, np.ndarray): 
            # hand over to __add__ for densification
            return NotImplemented

        if isinstance(other, MapArray):
            return _iadd_impl(self, other)

        # else, other is a scalar.
        dt = np.asarray(other).dtype     # XXX there must be a more direct way
        arr_other = MapArray(shape=self.shape,
                             dtype=dt,
                             fill_value=other)
        return _iadd_impl(self, arr_other)

    def __add__(self, other):
        if isinstance(self, MapArray):
            if isinstance(other, np.ndarray):
                # Densify and return dense result
                return self.todense() + other
            else:
                newobj = self.copy()
                return newobj.__iadd__(other)
        elif isinstance(other, MapArray):
            return other.__add__(self)
        else:
            # how come?
            raise RuntimeError("__add__ : never be here ", self, other)

    def __imul__(MapArray self not None, other):

        if isinstance(other, np.ndarray): 
            # hand over to __mul__ for densification
            return NotImplemented

        if isinstance(other, MapArray):
            return _imul_impl(self, other)

        # else, other is a scalar.
        dt = np.asarray(other).dtype     # XXX there must be a more direct way
        arr_other = MapArray(shape=self.shape,
                             dtype=dt,
                             fill_value=other)
        return _imul_impl(self, arr_other)

    def __mul__(self, other):
        if isinstance(self, MapArray):
            if isinstance(other, np.ndarray):
                # Densify and return dense result
                return self.todense() * other
            else:
                newobj = self.copy()
                return newobj.__imul__(other)
        elif isinstance(other, MapArray):
            return other.__mul__(self)
        else:
            # how come?
            raise RuntimeError("__mul__ : never be here ", self, other)

    ########### Booleans ########################

    def __richcmp__(self, other, int op):
        if not isinstance(self, MapArray):
            # __richcmp__ seems to sort out reversed ops ( $1 < m$ -> $m >= 1$ )
            # automagically
            raise ValueError("__richcmp__: %s %s %s" % (self, other, op))

        if isinstance(other, np.ndarray):
            # XXX <object>ndarray must have __richcmp__ or something
            if op == 0:
                return self.todense() < other
            elif op == 1:
                return self.todense() <= other
            elif op == 2:
                return self.todense() == other
            elif op == 3:
                return self.todense() != other
            elif op == 4:
                return self.todense() > other
            elif op == 5:
                return self.todense() >= other
            else:
                raise ValueError("dense cmp: op = ." % op)

        if isinstance(other, MapArray):
            return _richcmp_impl(self, other, op)

        # else, other is a scalar
        dt = np.asarray(other).dtype     # XXX there must be a more direct way
        arr_other = MapArray(shape=self.shape,
                             dtype=dt,
                             fill_value=other)
        return _richcmp_impl(self, arr_other, op)


def _richcmp_impl(MapArray self not None, MapArray other not None, int op):
    """ Sparse <op> sparse implementation of __richcmp__.

        Figure out the common dtype, copy if necessary. Then dispatch
        on the type.

        XXX: this can be made copy less (ditto for binops).
    """
    # figure out dtypes, copy if necessary         
    if self.typenum != other.typenum:
        res_type = np.promote_types(self.dtype, other.dtype)
        if res_type.num != self.typenum:
            # upcast self and operate on the copy
            newobj = self.astype(res_type)
            return _richcmp_impl(newobj, other, op)

        # by this stage, self.dtype == res_type
        if self.typenum != other.typenum:
            # upcast other
            other = other.astype(res_type)

    # by now, both self and other are of the same dtype
    result = MapArray(dtype=bool)

    # dispatch on the types
    {{for NUM, CT in zip(TNUMS, CTYPES)}}
    if self.typenum == {{NUM}}:
        if op == 0:
            result.p.npy_bool_ptr.apply_binop[{{CT}}](less[{{CT}}],
                                                     self.p.{{CT}}_ptr,
                                                     other.p.{{CT}}_ptr)
        elif op == 1:
            result.p.npy_bool_ptr.apply_binop[{{CT}}](less_equal[{{CT}}],
                                                     self.p.{{CT}}_ptr,
                                                     other.p.{{CT}}_ptr)
        elif op == 2:
            result.p.npy_bool_ptr.apply_binop[{{CT}}](equal[{{CT}}],
                                                     self.p.{{CT}}_ptr,
                                                     other.p.{{CT}}_ptr)
        elif op == 3:
            result.p.npy_bool_ptr.apply_binop[{{CT}}](not_equal[{{CT}}],
                                                     self.p.{{CT}}_ptr,
                                                     other.p.{{CT}}_ptr)
        elif op == 4:
            result.p.npy_bool_ptr.apply_binop[{{CT}}](greater[{{CT}}],
                                                     self.p.{{CT}}_ptr,
                                                     other.p.{{CT}}_ptr)
        elif op == 5:
            result.p.npy_bool_ptr.apply_binop[{{CT}}](greater_equal[{{CT}}],
                                                     self.p.{{CT}}_ptr,
                                                     other.p.{{CT}}_ptr)
        else:
            raise ValueError("sparse cmp: op = ." % op)
        return result

    {{endfor}}


def _iadd_impl(MapArray self not None, MapArray other not None):
    """ Sparse <op> sparse implementation of __iadd__.

        Figure out the common dtype, copy if necessary. Then dispatch
        on the type.
    """
    # figure out dtypes, copy if necessary
    if self.typenum != other.typenum:
        res_type = np.promote_types(self.dtype, other.dtype)
        if res_type.num != self.typenum:
            # upcast self and operate on the copy
            newobj = self.astype(res_type)
            return _iadd_impl(newobj, other)

        # by this stage, self.dtype == res_type
        if self.typenum != other.typenum:
            # upcast other
            other = other.astype(res_type)

    # dispatch
    {{for NUM, CT in zip(TNUMS, CTYPES)}}
    if self.typenum == {{NUM}}:
        self.p.{{CT}}_ptr.inplace_binary_op(linear_binary_op[{{CT}}],
                                            (<MapArray>other).p.{{CT}}_ptr, <{{CT}}>1, <{{CT}}>1)
        return self
    {{endfor}}
    return NotImplemented


def _imul_impl(MapArray self, MapArray other):
    """ Sparse <op> sparse implementation of __imul__.

        Figure out the common dtype, copy if necessary. Then dispatch
        on the type.

        XXX: this is too similar to _iadd_impl. Templating?

    """
    # figure out dtypes, copy if necessary
    other.typenum = other.dtype.num
    if self.typenum != other.typenum:
        res_type = np.promote_types(self.dtype, other.dtype)
        if res_type.num != self.typenum:
            # upcast self and operate on the copy
            newobj = self.astype(res_type)
            return _imul_impl(newobj, other)

        # by this stage, self.dtype == res_type
        if self.typenum != other.typenum:
            # upcast other
            other = other.astype(res_type)

    # dispatch
    {{for NUM, CT in zip(TNUMS, CTYPES)}}
    if self.typenum == {{NUM}}:
        self.p.{{CT}}_ptr.inplace_binary_op(mul_binary_op[{{CT}}],
                                            (<MapArray>other).p.{{CT}}_ptr, <{{CT}}>1, <{{CT}}>0)
        return self
    {{endfor}}
    return NotImplemented


cnp.import_array()
